<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
<title>WHO VQ — 潮干狩り</title>
<style>
  /* ========== Reset ========== */
  *{margin:0;padding:0;box-sizing:border-box}
  html,body{height:100%;background:#000;color:#fff;font-family:system-ui,"Noto Sans JP","Hiragino Kaku Gothic ProN","Meiryo",sans-serif;overflow:hidden}

  /* ========== Layout ========== */
  .game{position:relative;width:100vw;height:100vh;overflow:hidden;touch-action:none;}
  .bg{position:absolute;inset:0;background-size:cover;background-position:center;background-repeat:no-repeat;z-index:0;}
  /* 背景は好きな画像に差し替えOK */
  .bg.sky{background-image:url("public/assets/stage1/sky_morning.png");}
  .bg.sea{background-image:url("public/assets/stage1/sea.png");opacity:.95}
  .bg.sand{background-image:url("public/assets/stage1/sand.png");}

  /* 砂なで用マスク（キャンバス） */
  #sandCanvas{position:absolute;inset:0;z-index:3;touch-action:none;}

  /* 貝とクリック判定 */
  .clams{position:absolute;inset:0;z-index:4;pointer-events:none;}
  .clam{position:absolute;width:64px;height:48px;transform:translate(-50%, -50%);opacity:0;pointer-events:auto;cursor:pointer;transition:opacity .25s;}
  .clam.revealed{opacity:1;}
  .clam img{width:100%;height:100%;object-fit:contain;filter:drop-shadow(0 2px 2px rgba(0,0,0,.4))}

  /* キャラクター（最前面に固定） */
  #charWrap{position:absolute;left:50%;bottom:10vh;transform:translateX(-50%);z-index:7;pointer-events:none;}
  #char{display:block;width:min(38vw, 420px);height:auto;image-rendering:auto;filter:drop-shadow(0 4px 8px rgba(0,0,0,.55))}
  /* アイドルはゆっくり上下移動のみ（1枚静止） */
  @keyframes idleFloat {
    0%{transform:translate(-50%, 0)}
    50%{transform:translate(-50%, -6px)}
    100%{transform:translate(-50%, 0)}
  }
  #charWrap.idle{animation:idleFloat 3.6s ease-in-out infinite;}

  /* アクセサリー（キャラの上・頭基準） */
  #accLayer{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:8;}
  .acc{position:absolute;transform-origin:center center;pointer-events:none;image-rendering:auto;filter:drop-shadow(0 2px 2px rgba(0,0,0,.4))}
  .acc.hidden{display:none;}

  /* HUD */
  .hud{position:absolute;left:0;right:0;top:0;display:flex;gap:8px;align-items:center;justify-content:space-between;padding:10px 12px;z-index:9;background:linear-gradient(180deg,rgba(0,0,0,.55),rgba(0,0,0,0))}
  .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.45);backdrop-filter:blur(6px);font-size:14px;}
  .btn{border:none;border-radius:10px;padding:8px 12px;background:#ffd76a;color:#432;font-weight:700;cursor:pointer;box-shadow:0 2px 0 rgba(0,0,0,.25)}
  .btn:active{transform:translateY(1px);box-shadow:0 1px 0 rgba(0,0,0,.25)}

  /* トースト */
  #toast{position:absolute;left:50%;top:9.5vh;transform:translateX(-50%);z-index:10;background:rgba(0,0,0,.7);padding:10px 14px;border-radius:10px;opacity:0;pointer-events:none;transition:opacity .25s}
  #toast.show{opacity:1}

  /* 読み込みオーバーレイ（前フレーム保持のため透明） */
  #loading{position:absolute;inset:0;z-index:6;background:transparent;display:none}

  /* 小さめ端末対策 */
  @media (max-width: 480px){
    #char{width:58vw}
    .clam{width:52px;height:40px}
  }
</style>
</head>
<body>
<div class="game" id="game">
  <div class="bg sky"></div>
  <div class="bg sea"></div>
  <div class="bg sand"></div>

  <canvas id="sandCanvas" width="1920" height="1080"></canvas>
  <div class="clams" id="clams"></div>

  <!-- キャラ最前面 -->
  <div id="charWrap" class="idle">
    <img id="char" alt="character" src="public/assets/stage1/pink_open.png">
    <div id="accLayer"></div>
  </div>

  <div class="hud">
    <div class="pill" id="statPill">
      <span>会話チケット：</span><b id="ticketCount">0</b>
      <span style="margin-left:10px">アクセP：</span><b id="accPoint">0</b>
    </div>
    <div style="display:flex;gap:8px">
      <button class="btn" id="btnBack">戻る</button>
      <button class="btn" id="btnHint">ヒント</button>
    </div>
  </div>

  <div id="toast">+1 shell / +1P</div>
  <div id="loading" aria-hidden="true"></div>
</div>

<script>
(() => {
  /* ===========================================================
     設定（ここだけ触ればアクセの「小さめ＆頭の上」調整ができます）
     =========================================================== */

  // キャラの頭アンカー（キャラ画像の相対座標：0〜1）
  // 例：x=0.5 は画像中央、y=0.18 は画像の上から18%の高さ（頭の上あたり）
  const HEAD_ANCHORS = {
    pink:   { x: 0.50, y: 0.18, baseScale: 0.18 },
    blue:   { x: 0.50, y: 0.18, baseScale: 0.18 },
    green:  { x: 0.50, y: 0.18, baseScale: 0.18 },
    purple: { x: 0.50, y: 0.18, baseScale: 0.18 },
    // 友だち(friend) など色外カテゴリがあれば追加可
    friend: { x: 0.50, y: 0.18, baseScale: 0.18 },
  };

  // さらに微調整したい場合は、アクセごとのオフセット（px）と倍率を指定
  // name はファイル名（拡張子除く）に一致させると便利
  const ACCESSORY_FINE_TUNE = {
    // 例:
    // "ribbon_red": { dx: 0, dy: -4, scaleMul: 0.92 },
  };

  // アクセ画像のベースパス（統一ルール）
  const ACC_BASE = "public/accessories/";

  // キャラ画像のベースパス
  const CHAR_BASE = "public/assets/stage1/";

  // 砂なで半径（px）
  const BRUSH_RADIUS = 26;

  // 露出に必要な透明化割合の閾値（低い方が見えやすい）
  const REVEAL_THRESHOLD = 0.55;

  // 貝の生成数（適宜）
  const CLAM_COUNT = 8;

  // 回収時の加点（既存ロジックがあれば同キーで合算）
  const REWARD = { ticket: 1, accPoint: 1 };

  /* ===========================================================
     互換：who_char_color から who_character へ移行
     =========================================================== */
  function migrateLegacyCharacter() {
    try {
      const old = localStorage.getItem("who_char_color");
      if (!old) return;
      // 旧値例: "pink" / "blue" / "green" / "purple" / "friend"
      const val = old.replace(/"/g, '').trim();
      const obj = { type: "tane", color: val };
      localStorage.setItem("who_character", JSON.stringify(obj));
      // 以後参照しないよう削除（好みで残しても可）
      // localStorage.removeItem("who_char_color");
    } catch(e){}
  }

  function readCharacter() {
    migrateLegacyCharacter();
    const raw = localStorage.getItem("who_character");
    if (!raw) return { type:"tane", color:"pink" }; // デフォルト
    try {
      const obj = JSON.parse(raw);
      if (!obj || obj.type !== "tane") return { type:"tane", color:"pink" };
      const color = (obj.color||"pink");
      return { type:"tane", color };
    } catch(e) {
      return { type:"tane", color:"pink" };
    }
  }

  /* ===========================================================
     画像ローダ（フォールバック順：_open → _closed → .png）
     =========================================================== */
  async function loadSpriteWithFallback(color, base=CHAR_BASE) {
    const trials = [`${color}_open.png`, `${color}_closed.png`, `${color}.png`];
    for (const name of trials) {
      const url = base + name;
      try {
        await ensureImage(url);
        return url;
      } catch(e){/* try next */}
    }
    // 何も読めない場合：代替表現は出さず、既存のまま（前フレーム保持）にするため null
    return null;
  }

  function ensureImage(src) {
    return new Promise((res, rej) => {
      const im = new Image();
      im.onload = () => res(src);
      im.onerror = () => rej(new Error("img load failed:"+src));
      im.src = src;
    });
  }

  /* ===========================================================
     アクセ装着状態の読み込み
     形式：who_accessory_equip = ["ribbon_red","star_small"] または { slot1:"xxx", ... }
     =========================================================== */
  function readAccessoryEquip() {
    const raw = localStorage.getItem("who_accessory_equip");
    if (!raw) return [];
    try {
      const v = JSON.parse(raw);
      if (Array.isArray(v)) return v;
      if (v && typeof v === "object") {
        return Object.values(v).filter(Boolean);
      }
    } catch(e){}
    return [];
  }

  /* ===========================================================
     HUD counters
     =========================================================== */
  function readIntLS(key, def=0){
    const v = parseInt(localStorage.getItem(key) || `${def}`, 10);
    return isNaN(v) ? def : v;
  }
  function writeIntLS(key, val){
    localStorage.setItem(key, String(val));
  }

  /* ===========================================================
     砂なで＆貝配置
     =========================================================== */
  const gameEl = document.getElementById("game");
  const sandCanvas = document.getElementById("sandCanvas");
  const ctx = sandCanvas.getContext("2d");
  const clamsEl = document.getElementById("clams");
  let canvasW, canvasH, isPointerDown=false;

  function resizeCanvas(){
    // 固定解像度で内部を描き、CSSで拡縮
    canvasW = sandCanvas.width;
    canvasH = sandCanvas.height;
    // 初期は砂で覆う（濃いレイヤー）
    ctx.clearRect(0,0,canvasW,canvasH);
    ctx.fillStyle = "rgba(0,0,0,0.32)"; // 砂カバー（やや暗）
    ctx.fillRect(0,0,canvasW,canvasH);
  }

  function getCanvasPos(evt){
    const rect = sandCanvas.getBoundingClientRect();
    const pt = (evt.touches && evt.touches[0]) ? evt.touches[0] : evt;
    const x = (pt.clientX - rect.left) * (sandCanvas.width / rect.width);
    const y = (pt.clientY - rect.top)  * (sandCanvas.height / rect.height);
    return {x,y};
  }

  function brush(x,y){
    const g = ctx.createRadialGradient(x,y,0,x,y,BRUSH_RADIUS);
    g.addColorStop(0,"rgba(0,0,0,0)");
    g.addColorStop(1,"rgba(0,0,0,0.6)");
    ctx.globalCompositeOperation = "destination-out";
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(x,y,BRUSH_RADIUS,0,Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation = "source-over";
    // 見えてきた貝を reveal
    revealClamsUnder(x,y,BRUSH_RADIUS*1.1);
  }

  function setupBrushEvents(){
    sandCanvas.addEventListener("pointerdown",(e)=>{isPointerDown=true; sandCanvas.setPointerCapture(e.pointerId); const p=getCanvasPos(e); brush(p.x,p.y);});
    sandCanvas.addEventListener("pointermove",(e)=>{if(!isPointerDown) return; const p=getCanvasPos(e); brush(p.x,p.y);});
    sandCanvas.addEventListener("pointerup",()=>{isPointerDown=false;});
    sandCanvas.addEventListener("pointercancel",()=>{isPointerDown=false;});
    sandCanvas.addEventListener("touchstart",(e)=>{const p=getCanvasPos(e); brush(p.x,p.y);},{passive:true});
    sandCanvas.addEventListener("touchmove",(e)=>{if((e.touches||[]).length){const p=getCanvasPos(e); brush(p.x,p.y);}},{passive:true});
    sandCanvas.addEventListener("touchend",()=>{});
  }

  function rand(min,max){ return Math.random()*(max-min)+min; }

  function spawnClams(n=CLAM_COUNT){
    clamsEl.innerHTML = "";
    for(let i=0;i<n;i++){
      const x = rand(10, 90); // vw %
      const y = rand(30, 75); // vh %
      const el = document.createElement("div");
      el.className = "clam";
      el.style.left = x + "vw";
      el.style.top  = y + "vh";
      const img = document.createElement("img");
      img.alt = "clam";
      img.src = "public/assets/stage1/clam.png";
      el.appendChild(img);
      el.addEventListener("click", onCollectClam, {passive:true});
      clamsEl.appendChild(el);
    }
  }

  function revealClamsUnder(x,y,r){
    // 簡易 —— キャンバスに対する%座標に換算して近傍の貝を出す
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const px = x / sandCanvas.width  * vw;
    const py = y / sandCanvas.height * vh;

    const clams = [...clamsEl.children];
    clams.forEach(c=>{
      const rect = c.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top  + rect.height/2;
      const d = Math.hypot(cx - px, cy - py);
      if (d < (r * (vw / sandCanvas.width)) * 1.15) {
        c.classList.add("revealed");
      }
    });
  }

  function onCollectClam(e){
    const node = e.currentTarget;
    if (!node.classList.contains("revealed")) return;
    node.removeEventListener("click", onCollectClam);
    node.style.pointerEvents = "none";
    node.style.transition = "transform .25s, opacity .25s";
    node.style.transform = "translate(-50%,-50%) scale(0.6)";
    node.style.opacity = "0";
    setTimeout(()=>node.remove(), 260);
    // 報酬付与（既存のキーを尊重）
    const t = readIntLS("who_tickets", 0) + REWARD.ticket;
    const p = readIntLS("who_accessory_points", 0) + REWARD.accPoint;
    writeIntLS("who_tickets", t);
    writeIntLS("who_accessory_points", p);
    // HUD更新
    updateHUD();
    showToast(`+${REWARD.ticket} ticket / +${REWARD.accPoint}P`);
  }

  /* ===========================================================
     キャラ＆アクセ描画（アクセは「頭上に小さく」）
     =========================================================== */
  const charWrap = document.getElementById("charWrap");
  const charImg  = document.getElementById("char");
  const accLayer = document.getElementById("accLayer");

  let currentColor = "pink";
  let lastCharURL = null;
  let holdTimer = null;

  async function setupCharacter() {
    const { color } = readCharacter();
    currentColor = color in HEAD_ANCHORS ? color : "pink";

    // 読み込み中はオーバーレイを出す（前フレーム保持）
    const loading = document.getElementById("loading");
    loading.style.display = "block";

    const url = await loadSpriteWithFallback(currentColor);
    if (url) {
      charImg.src = url;
      lastCharURL = url;
    }
    // 保険タイマー：1.6s後には強制解除
    setTimeout(()=>{ loading.style.display = "none"; }, 1600);
    charWrap.classList.add("idle");

    // アクセ再描画
    await drawAccessories();
  }

  function charNaturalSize(){
    // 実サイズ（ロード済み画像の width/height）
    const w = charImg.naturalWidth || 512;
    const h = charImg.naturalHeight || 512;
    return {w, h};
  }

  function charRenderedBox(){
    // 画面上での描画サイズを取得
    const rect = charImg.getBoundingClientRect();
    return rect; // {left,top,width,height,...}
  }

  async function drawAccessories(){
    accLayer.innerHTML = "";
    const equips = readAccessoryEquip(); // ["xxx","yyy"]
    if (!equips.length) return;

    const anchor = HEAD_ANCHORS[currentColor] || HEAD_ANCHORS.pink;
    const { baseScale } = anchor;
    const rect = charRenderedBox();

    // キャラ画像上のアンカー座標（画面px）
    const ax = rect.left + rect.width  * anchor.x;
    const ay = rect.top  + rect.height * anchor.y;

    // 基本スケール：キャラ幅に対する割合で小さめに
    // baseScale は「キャラ幅×baseScale」でアクセ幅(px)を決める
    const baseAccPx = rect.width * baseScale;

    for (const name of equips){
      const src = `${ACC_BASE}${name}.png`;
      try {
        await ensureImage(src);
      } catch(e) {
        // 画像が無い場合はスキップ（フォールバック表示はしない）
        continue;
      }
      const fine = ACCESSORY_FINE_TUNE[name] || {dx:0, dy:0, scaleMul:1.0};
      const el = document.createElement("img");
      el.className = "acc";
      el.alt = name;
      el.src = src;

      // 画像の実サイズを取ってアスペ比維持で縮小
      const tmp = await loadImageElement(src);
      const iw = tmp.naturalWidth || 256;
      const ih = tmp.naturalHeight || 256;
      const aspect = iw / ih;

      // 幅を baseAccPx に、微調整倍率を掛ける
      const w = baseAccPx * (fine.scaleMul || 1.0);
      const h = w / aspect;

      // 配置（アンカー＋微調整オフセット）
      const left = (ax + (fine.dx||0)) - w/2;
      const top  = (ay + (fine.dy||0)) - h/2;

      el.style.width = `${w}px`;
      el.style.height = `${h}px`;
      el.style.left = `${left}px`;
      el.style.top  = `${top}px`;
      accLayer.appendChild(el);
    }
  }

  function loadImageElement(src){
    return new Promise((res, rej)=>{
      const im = new Image();
      im.onload = ()=>res(im);
      im.onerror = rej;
      im.src = src;
    });
  }

  // 単発 dig/hold 表現（1秒だけ closed にして戻す）
  async function pulseHoldOnce(){
    if (holdTimer) clearTimeout(holdTimer);
    const url = CHAR_BASE + `${currentColor}_closed.png`;
    try {
      await ensureImage(url);
      charWrap.classList.remove("idle");
      charImg.src = url;
      holdTimer = setTimeout(()=>{
        if (lastCharURL) charImg.src = lastCharURL;
        charWrap.classList.add("idle");
        holdTimer = null;
      }, 1000);
    } catch(e){
      // 無ければスキップしてそのまま（代替は出さない）
    }
  }

  /* ===========================================================
     HUD / トースト / ボタン
     =========================================================== */
  const ticketEl = document.getElementById("ticketCount");
  const accPntEl = document.getElementById("accPoint");
  const toastEl = document.getElementById("toast");

  function updateHUD(){
    ticketEl.textContent = readIntLS("who_tickets", 0);
    accPntEl.textContent = readIntLS("who_accessory_points", 0);
  }

  let toastTimer=null;
  function showToast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    if (toastTimer) clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>toastEl.classList.remove("show"), 1200);
  }

  document.getElementById("btnBack").addEventListener("click", ()=>{
    // 最後のページ保存
    localStorage.setItem("who_lastPage", "asari.html");
    // 戻る遷移（プロジェクトの規約に合わせて修正）
    location.href = "collection.html";
  });

  document.getElementById("btnHint").addEventListener("click", ()=>{
    // ヒント：一瞬 hold アニメを出す
    pulseHoldOnce();
    showToast("砂の濃い所をなでてみてね");
  });

  /* ===========================================================
     画面更新とリスナ
     =========================================================== */
  window.addEventListener("resize", ()=>{
    // リサイズの度にアクセ再配置
    drawAccessories();
  });

  // 初期化
  function init(){
    resizeCanvas();
    setupBrushEvents();
    spawnClams(CLAM_COUNT);
    setupCharacter();
    updateHUD();
    localStorage.setItem("who_lastPage", "asari.html");
  }

  // 起動
  init();

})();
</script>
</body>
</html>
