<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>WHO VQ — 潮干狩り（砂なぞりシンプル）</title>
  <style>
    /* ===== Reset & Base ===== */
    *,*::before,*::after{box-sizing:border-box}
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,"Noto Sans JP",sans-serif}

    /* ===== Layers ===== */
    .game{position:relative;width:100vw;height:100vh;overflow:hidden;touch-action:none}
    #bg{position:absolute;inset:0;background-image:url('public/items/bg/beach_day.jpg');background-size:cover;background-position:center;z-index:0;transition:filter .8s ease}
    #shellLayer{position:absolute;inset:0;z-index:1;pointer-events:none}
    #shellLayer img.shell{position:absolute;width:72px;height:72px;object-fit:contain;transform:translate(-50%,-50%);pointer-events:auto;cursor:pointer;filter:drop-shadow(0 4px 10px rgba(0,0,0,.45));}
    #sand{position:absolute;inset:0;z-index:2;touch-action:none}

    /* HUD */
    #hud{position:absolute;left:0;right:0;top:0;z-index:5;display:flex;gap:8px;align-items:center;justify-content:space-between;padding:10px 12px;background:linear-gradient(180deg,rgba(0,0,0,.55),rgba(0,0,0,0))}
    #hud .chip{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.18)}
    #hud .btn{padding:8px 12px;border-radius:12px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.18);cursor:pointer}
    #cta{position:absolute;left:50%;bottom:18px;transform:translateX(-50%);z-index:6;display:none}
    #cta button{padding:12px 18px;border:0;border-radius:14px;font-weight:700;background:linear-gradient(90deg,#7cf3c9,#8ee8ff);color:#06251a;box-shadow:0 10px 24px rgba(124,243,201,.25);cursor:pointer}

    /* Character */
    #friend{position:absolute;z-index:4;width:16vh;min-width:84px;image-rendering:auto;filter:drop-shadow(0 8px 18px rgba(0,0,0,.5));transform:translate(-50%,-50%)}
    #bubble{position:absolute;z-index:5;min-width:120px;max-width:52vw;padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.2);backdrop-filter:blur(6px);transform:translate(-50%,-130%);opacity:0;transition:opacity .25s ease}

    /* Animations */
    @keyframes spinOnce{from{transform:translate(-50%,-50%) rotate(0deg)}to{transform:translate(-50%,-50%) rotate(360deg)}}
    .spin{animation:spinOnce .45s cubic-bezier(.2,.8,.2,1)}

    /* End brightening */
    .bright{filter:brightness(1.18) saturate(1.08)}
  </style>
</head>
<body>
  <div class="game" id="game">
    <div id="bg" aria-hidden="true"></div>
    <div id="shellLayer" aria-label="shells"></div>
    <canvas id="sand"></canvas>

    <img id="friend" alt="character" />
    <div id="bubble" role="status">やった！アサリを手に入れた</div>

    <div id="hud">
      <div class="chip">回収: <b id="count">0</b> 個</div>
      <div style="flex:1"></div>
      <button class="btn" id="btnReset">砂を戻す</button>
      <button class="btn" id="btnBack">戻る</button>
    </div>

    <div id="cta"><button id="toCollection">全部回収！ 図鑑へ →</button></div>
  </div>

  <script>
  ;(() => {
    // ====== Config ======
    const CHARACTER_KEY = 'who_character';
    const STORAGE_KEY = 'who_shells'; // { items: {asari1: n, ...}, updatedAt, schema }
    const IMG_BASE_PRIMARY = 'public/items/shells';
    const IMG_BASE_FALLBACK = 'public/shells';

    // 貝の定義（今回はシンプルにアサリ中心）
    const SHELL_MASTER = {
      asari1: { name: 'アサリ(小)' },
      asari2: { name: 'アサリ(中)' },
      asari3: { name: 'アサリ(大)' }
    };

    // 置く数（必要に応じて調整）
    const SHELL_POOL = [
      { id: 'asari1', n: 5 },
      { id: 'asari2', n: 4 },
      { id: 'asari3', n: 3 },
    ];

    // キャンバス消しゴムサイズ
    const ERASER = { down: 30, move: 26 }; // px

    // ====== State ======
    const game = document.getElementById('game');
    const bg = document.getElementById('bg');
    const shellLayer = document.getElementById('shellLayer');
    const sand = document.getElementById('sand');
    const ctx = sand.getContext('2d', { willReadFrequently: true });
    const friend = document.getElementById('friend');
    const bubble = document.getElementById('bubble');
    const countEl = document.getElementById('count');
    const cta = document.getElementById('cta');

    let shells = []; // {el, id, x, y, collected}
    let collected = 0;
    let isDown = false;
    let last = null; // last pointer pos

    // ====== Helpers ======
    const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));

    function shellSrc(id){
      const pri = `${IMG_BASE_PRIMARY}/${id}.png`;
      const fb = `${IMG_BASE_FALLBACK}/${id}.png`;
      return { pri, fb };
    }

    function loadCharacter(){
      const color = (localStorage.getItem(CHARACTER_KEY)||'pink').replace(/[^a-z]/g,'');
      const try1 = `public/stage1/${color}_open.png`;
      const try2 = `public/assets/stage1/${color}_open.png`;
      friend.src = try1;
      friend.alt = `character ${color}`;
      friend.onerror = () => { friend.onerror=null; friend.src = try2; };
      // 初期位置
      friend.style.left = '50%';
      friend.style.top  = '65%';
    }

    function saveInventory(deltaId){
      // 既存読み込み
      let inv = { items: {}, schema: 'who_shells/v1', updatedAt: new Date().toISOString() };
      try{ const raw = JSON.parse(localStorage.getItem(STORAGE_KEY)||'{}'); if(raw && raw.items) inv = raw; }catch{}
      inv.items[deltaId] = (inv.items[deltaId]||0)+1;
      inv.updatedAt = new Date().toISOString();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(inv));
    }

    // ====== Sand (mask) ======
    function resizeCanvas(){
      sand.width = game.clientWidth;
      sand.height = game.clientHeight;
      drawSand();
    }

    function drawSand(){
      // 砂っぽい色（簡易）。必要なら画像テクスチャに差し替え可。
      const g1 = ctx.createLinearGradient(0,0,0,sand.height);
      g1.addColorStop(0,'#e7d7a8');
      g1.addColorStop(1,'#d9c49a');
      ctx.globalCompositeOperation = 'source-over';
      ctx.clearRect(0,0,sand.width,sand.height);
      ctx.fillStyle = g1;
      ctx.fillRect(0,0,sand.width,sand.height);
      // うっすら陰影
      const g2 = ctx.createRadialGradient(sand.width*0.5,sand.height*0.85,20,sand.width*0.5,sand.height*0.7,Math.max(sand.width,sand.height));
      g2.addColorStop(0,'rgba(0,0,0,0)');
      g2.addColorStop(1,'rgba(0,0,0,.12)');
      ctx.fillStyle = g2;
      ctx.fillRect(0,0,sand.width,sand.height);
    }

    function eraseAt(x,y,r){
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function lineErase(x0,y0,x1,y1,r){
      const dx=x1-x0, dy=y1-y0;
      const dist = Math.hypot(dx,dy);
      const steps = Math.max(1, Math.ceil(dist/(r*0.6)));
      for(let i=0;i<=steps;i++){
        const t=i/steps; eraseAt(x0+dx*t,y0+dy*t,r);
      }
    }

    function isRevealed(x,y){
      // その座標周辺の砂のアルファを確認（軽量チェック）
      const s=8; // サンプル半径
      const img = ctx.getImageData(clamp(Math.floor(x-s),0,sand.width-1), clamp(Math.floor(y-s),0,sand.height-1), s*2, s*2).data;
      let covered=0, total=(s*2)*(s*2);
      for(let i=3;i<img.length;i+=4){ if(img[i]>24) covered++; }
      const coveredRatio = covered/total; // 1 = 砂で覆われている
      return coveredRatio < 0.25; // 75% 以上削れていたら露出とみなす
    }

    // ====== Shells ======
    function placeShells(){
      shellLayer.innerHTML = '';
      shells.length = 0;
      const rect = game.getBoundingClientRect();
      const W = rect.width, H = rect.height;
      const margin = 64; // 端から離す

      const all = [];
      SHELL_POOL.forEach(p=>{ for(let i=0;i<p.n;i++) all.push(p.id); });

      const points = [];
      for(const id of all){
        let tries=0, x=0,y=0; const minDist=80;
        do {
          x = margin + Math.random()*(W-margin*2);
          y = H*0.42 + Math.random()*(H*0.48); // 砂浜帯
          tries++;
        } while(tries<80 && points.some(pt=>Math.hypot(pt.x-x,pt.y-y)<minDist));
        points.push({x,y});

        const img = new Image();
        const {pri, fb} = shellSrc(id);
        img.src = pri; img.onerror = ()=>{ img.onerror=null; img.src = fb; };
        img.alt = SHELL_MASTER[id]?.name || id;
        img.className = 'shell';
        img.style.left = x+'px';
        img.style.top  = y+'px';
        img.addEventListener('click', () => tryCollect(img,id,x,y));
        shellLayer.appendChild(img);
        shells.push({el:img,id,x,y,collected:false});
      }
    }

    function tryCollect(el,id,x,y){
      if(el.dataset.collected==='1') return;
      if(!isRevealed(x,y)){
        // 少しヒント: ここを消してね
        showBubble('砂をもう少しなぞって！');
        return;
      }
      el.dataset.collected='1';
      el.classList.add('spin');
      setTimeout(()=>{ el.style.visibility='hidden'; }, 420);
      collected++;
      countEl.textContent = String(collected);
      saveInventory(id);
      showBubble('やった！アサリを手に入れた');
      if(collected === shells.length) onAllCollected();
    }

    function onAllCollected(){
      bg.classList.add('bright');
      cta.style.display = 'block';
    }

    function showBubble(text){
      bubble.textContent = text;
      bubble.style.left = friend.style.left || '50%';
      bubble.style.top  = friend.style.top  || '60%';
      bubble.style.opacity = '1';
      clearTimeout(showBubble._t);
      showBubble._t = setTimeout(()=>{ bubble.style.opacity = '0'; }, 1100);
    }

    // ====== Pointer erase ======
    function toXY(e){
      const r = sand.getBoundingClientRect();
      const x = (e.clientX ?? (e.touches&&e.touches[0]?.clientX)) - r.left;
      const y = (e.clientY ?? (e.touches&&e.touches[0]?.clientY)) - r.top;
      return {x,y};
    }

    sand.addEventListener('pointerdown', e=>{ isDown=true; sand.setPointerCapture(e.pointerId); const {x,y}=toXY(e); eraseAt(x,y,ERASER.down); last={x,y}; });
    sand.addEventListener('pointermove', e=>{ const {x,y}=toXY(e); if(isDown && last){ lineErase(last.x,last.y,x,y,ERASER.move); last={x,y}; } target.x = x; target.y = y; });
    sand.addEventListener('pointerup',   ()=>{ isDown=false; last=null; });
    sand.addEventListener('pointercancel',()=>{ isDown=false; last=null; });

    // ====== Friend follows pointer ======
    const target = {x: window.innerWidth*0.5, y: window.innerHeight*0.65};
    const pos = {x: target.x, y: target.y};
    let t = 0;

    function animate(){
      t += 0.016;
      // 追従
      const k = 0.08; // 追従係数（小さいほどヌルヌル）
      pos.x += (target.x - pos.x)*k;
      pos.y += (target.y - pos.y)*k;
      const bob = Math.sin(t*2.6)*4; // 揺れ
      friend.style.left = pos.x + 'px';
      friend.style.top  = (pos.y + bob) + 'px';
      requestAnimationFrame(animate);
    }

    // ====== Buttons ======
    document.getElementById('btnBack').addEventListener('click',()=>{ history.back(); });
    document.getElementById('btnReset').addEventListener('click',()=>{ drawSand(); });
    document.getElementById('toCollection').addEventListener('click',()=>{ location.href='collection.html'; });

    // ====== Init ======
    function init(){
      loadCharacter();
      resizeCanvas();
      placeShells();
      collected = 0; countEl.textContent = '0';
      requestAnimationFrame(animate);
    }

    window.addEventListener('resize', ()=>{ resizeCanvas(); placeShells(); });
    document.addEventListener('DOMContentLoaded', init);
  })();
  </script>
</body>
</html>
